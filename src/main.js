import { parseMarkdown, parseBodyToElements } from "./parser.js";
import { generateDocxBlob } from "./docx-renderer.js";
import { generatePdfBlob } from "./pdf-renderer.js";
import { generateHtmlBlob } from "./html-export.js";
import { generateHTMLPreview } from "./html-preview.js";
import { getThemeList, getTheme } from "./themes/index.js";

const EXAMPLE_MD = `---
title: "Technical Documentation"
author: "KYOTU Technology"
date: "January 2025"
---

# Introduction

This document demonstrates the capabilities of **MD2DOCX** converter built by [KYOTU Technology](https://kyotu.tech). It supports various Markdown elements and generates professional Word documents.

## Text Formatting

Text can be **bold**, *italic* or \`inline code\`. You can also combine them: ***bold and italic***. Links work too: [visit our website](https://kyotu.tech).

## Lists

### Bullet List
- First item with some details
- Second item with **bold text**
- Third item with \`code\`

### Numbered List
1. Step one - initialize the project
2. Step two - configure settings
3. Step three - deploy to production

### Task List
- [x] Project setup completed
- [x] Core features implemented
- [ ] Documentation in progress
- [ ] Final review pending

## Data Table

| Service | Status | Uptime |
|---------|--------|--------|
| **API Gateway** | Active | 99.9% |
| **Database** | Active | 99.8% |
| **CDN** | Active | 100% |

## Code Example

\`\`\`typescript
interface Document {
  title: string;
  author: string;
  content: Element[];
}

async function generateDocx(doc: Document): Promise<Blob> {
  const elements = parseMarkdown(doc.content);
  return await createDocument(doc, elements);
}
\`\`\`

## Architecture Diagram

\`\`\`mermaid
graph LR
    A[Markdown] --> B[Parser]
    B --> C{Element Type}
    C -->|Text| D[Text Renderer]
    C -->|Code| E[Syntax Highlighter]
    C -->|Diagram| F[Kroki.io]
    D --> G[DOCX Output]
    E --> G
    F --> G
\`\`\`

#### Implementation Notes

This is an H4 heading - it also appears in the table of contents with proper indentation.

---

# Summary

Document generated by **MD2DOCX** - 100% client-side processing, no server required!

Built with ❤️ by KYOTU Technology
`;

const $ = (id) => document.getElementById(id);

const markdownInput = $("markdown");
const preview = $("preview");
const status = $("status");
const statusText = $("statusText");
const metaInfo = $("metaInfo");
const metaElements = $("metaElements");
const charCount = $("charCount");
const generateBtn = $("generateBtn");
const formatDropdown = $("formatDropdown");
const fileInput = $("fileInput");
const dropzone = $("dropzone");
const loadExample = $("loadExample");
const themeSelect = $("themeSelect");
const settingsBtn = $("settingsBtn");
const settingsPanel = $("settingsPanel");
const resizer = $("resizer");
const editorPanel = $("editorPanel");
const previewPanel = $("previewPanel");
const logoInput = $("logoInput");
const logoFileName = $("logoFileName");
const resetLogo = $("resetLogo");

let customLogoDataUrl = null;

const exportOptions = {
  showTitlePage: true,
  showToc: true,
  showHeader: true,
  showFooter: true,
  customLogo: null,
};

const toggles = {
  toggleTitlePage: "showTitlePage",
  toggleToc: "showToc",
  toggleHeader: "showHeader",
  toggleFooter: "showFooter",
};

Object.keys(toggles).forEach((id) => {
  const el = $(id);
  el.addEventListener("click", () => {
    const key = toggles[id];
    exportOptions[key] = !exportOptions[key];
    el.classList.toggle("active", exportOptions[key]);
    try {
      localStorage.setItem(
        "md2docx-options",
        JSON.stringify({
          showTitlePage: exportOptions.showTitlePage,
          showToc: exportOptions.showToc,
          showHeader: exportOptions.showHeader,
          showFooter: exportOptions.showFooter,
        })
      );
    } catch {}
  });
});

try {
  const savedOptions = localStorage.getItem("md2docx-options");
  if (savedOptions) {
    const opts = JSON.parse(savedOptions);
    Object.keys(opts).forEach((key) => {
      if (key in exportOptions) {
        exportOptions[key] = opts[key];
      }
    });
    Object.keys(toggles).forEach((id) => {
      const key = toggles[id];
      $(id).classList.toggle("active", exportOptions[key]);
    });
  }
} catch {}

settingsBtn.addEventListener("click", () => {
  settingsPanel.classList.toggle("open");
  if (settingsPanel.classList.contains("open")) {
    settingsBtn.style.color = "#f97c00";
  } else {
    settingsBtn.style.color = "";
  }
});

logoInput.addEventListener("change", (e) => {
  const file = e.target.files[0];
  if (file && file.type.startsWith("image/")) {
    const reader = new FileReader();
    reader.onload = (ev) => {
      customLogoDataUrl = ev.target.result;
      exportOptions.customLogo = customLogoDataUrl;
      logoFileName.textContent = file.name.length > 15 ? file.name.slice(0, 12) + "..." : file.name;
      resetLogo.classList.remove("hidden");
    };
    reader.readAsDataURL(file);
  }
});

resetLogo.addEventListener("click", () => {
  customLogoDataUrl = null;
  exportOptions.customLogo = null;
  logoInput.value = "";
  const theme = getTheme(themeSelect.value);
  logoFileName.textContent = theme.id === "kyotu" ? "KYOTU (default)" : "None";
  resetLogo.classList.add("hidden");
});

themeSelect.addEventListener("change", () => {
  updatePreview();
  if (!customLogoDataUrl) {
    const theme = getTheme(themeSelect.value);
    logoFileName.textContent = theme.id === "kyotu" ? "KYOTU (default)" : "None";
  }
});

generateBtn.addEventListener("click", () => {
  formatDropdown.classList.toggle("hidden");
});

document.addEventListener("click", (e) => {
  if (!generateBtn.contains(e.target) && !formatDropdown.contains(e.target)) {
    formatDropdown.classList.add("hidden");
  }
});

document.querySelectorAll(".format-option").forEach((btn) => {
  btn.addEventListener("click", async () => {
    const format = btn.dataset.format;
    formatDropdown.classList.add("hidden");
    await generateDocument(format);
  });
});

let isResizing = false;
resizer.addEventListener("mousedown", () => {
  isResizing = true;
  resizer.classList.add("dragging");
  document.body.style.cursor = "col-resize";
  document.body.style.userSelect = "none";
});

document.addEventListener("mousemove", (e) => {
  if (!isResizing) return;

  const container = editorPanel.parentElement;
  const containerRect = container.getBoundingClientRect();
  const percentage = ((e.clientX - containerRect.left) / containerRect.width) * 100;
  const clampedPercentage = Math.min(Math.max(percentage, 20), 80);

  editorPanel.style.flex = `0 0 ${clampedPercentage}%`;
  previewPanel.style.flex = `0 0 ${100 - clampedPercentage - 1}%`;
});

document.addEventListener("mouseup", () => {
  if (isResizing) {
    isResizing = false;
    resizer.classList.remove("dragging");
    document.body.style.cursor = "";
    document.body.style.userSelect = "";
  }
});

const themes = getThemeList();
themes.forEach((t) => {
  const opt = document.createElement("option");
  opt.value = t.id;
  opt.textContent = t.name;
  themeSelect.appendChild(opt);
});

const emptyStateHTML = `
<div class="text-center py-12">
  <div class="w-16 h-16 mx-auto mb-4 rounded-full bg-gradient-to-br from-kyotu-orange-light/20 to-kyotu-orange/20 flex items-center justify-center">
    <svg class="w-8 h-8 text-kyotu-orange" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
    </svg>
  </div>
  <p class="text-gray-400">Document preview will appear here</p>
  <p class="text-gray-300 text-sm mt-1">Start typing or load an example</p>
</div>
`;

function showStatus(text) {
  status.classList.remove("hidden");
  statusText.textContent = text;
}

function hideStatus() {
  status.classList.add("hidden");
}

function updatePreview() {
  const md = markdownInput.value;
  charCount.textContent = `${md.length} chars`;

  try {
    localStorage.setItem("md2docx-content", md);
  } catch {}

  if (!md.trim()) {
    preview.innerHTML = emptyStateHTML;
    metaInfo.classList.add("hidden");
    return;
  }

  const { metadata, body } = parseMarkdown(md);
  const elements = parseBodyToElements(body);
  const themeId = themeSelect.value;

  preview.innerHTML = generateHTMLPreview(elements, metadata, themeId);
  metaElements.textContent = elements.length;
  metaInfo.classList.remove("hidden");
}

async function generateDocument(format = "docx") {
  const md = markdownInput.value;
  if (!md.trim()) {
    alert("Please paste or load Markdown content!");
    return;
  }

  generateBtn.disabled = true;
  try {
    showStatus("Parsing...");
    const { metadata, body } = parseMarkdown(md);
    const elements = parseBodyToElements(body);
    const themeId = themeSelect.value;
    const filename = metadata.title || "document";

    if (format === "docx" || format === "all") {
      showStatus(`Generating DOCX (${elements.length} elements)...`);
      const docxBlob = await generateDocxBlob(metadata, elements, themeId, exportOptions);
      downloadBlob(docxBlob, `${filename}.docx`);
    }

    if (format === "pdf" || format === "all") {
      showStatus(`Generating PDF (${elements.length} elements)...`);
      const pdfBlob = await generatePdfBlob(metadata, elements, themeId, exportOptions);
      downloadBlob(pdfBlob, `${filename}.pdf`);
    }

    if (format === "html" || format === "all") {
      showStatus(`Generating HTML (${elements.length} elements)...`);
      const htmlBlob = generateHtmlBlob(elements, metadata, themeId);
      downloadBlob(htmlBlob, `${filename}.html`);
    }

    hideStatus();
  } catch (err) {
    console.error(err);
    hideStatus();
    alert(`Error: ${err.message}`);
  } finally {
    generateBtn.disabled = false;
  }
}

function downloadBlob(blob, filename) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}

function loadFile(file) {
  if (
    file &&
    (file.name.endsWith(".md") || file.name.endsWith(".txt") || file.type === "text/plain")
  ) {
    const reader = new FileReader();
    reader.onload = (e) => {
      markdownInput.value = e.target.result;
      updatePreview();
    };
    reader.readAsText(file);
  }
}

loadExample.addEventListener("click", () => {
  markdownInput.value = EXAMPLE_MD;
  updatePreview();
});
fileInput.addEventListener("change", (e) => loadFile(e.target.files[0]));

dropzone.addEventListener("dragover", (e) => {
  e.preventDefault();
  dropzone.classList.add("dragover");
});
dropzone.addEventListener("dragleave", () => dropzone.classList.remove("dragover"));
dropzone.addEventListener("drop", (e) => {
  e.preventDefault();
  dropzone.classList.remove("dragover");
  loadFile(e.dataTransfer.files[0]);
});

let previewTimeout;
markdownInput.addEventListener("input", () => {
  clearTimeout(previewTimeout);
  previewTimeout = setTimeout(updatePreview, 300);
});

markdownInput.addEventListener("keydown", (e) => {
  if (e.ctrlKey && e.key === "Enter") {
    e.preventDefault();
    generateDocument("docx");
  }
});

themeSelect.addEventListener("change", () => {
  try {
    localStorage.setItem("md2docx-theme", themeSelect.value);
  } catch {}
});

try {
  const savedTheme = localStorage.getItem("md2docx-theme");
  if (savedTheme && themes.some((t) => t.id === savedTheme)) {
    themeSelect.value = savedTheme;
  }
} catch {}

try {
  const savedContent = localStorage.getItem("md2docx-content");
  if (savedContent) {
    markdownInput.value = savedContent;
    updatePreview();
  }
} catch {}
