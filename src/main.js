import { parseMarkdown, parseBodyToElements } from "./parser.js";
import { generateDocxBlob } from "./docx-renderer.js";
import { generatePdfBlob } from "./pdf-renderer.js";
import { generateHtmlBlob } from "./html-export.js";
import { getThemeOrTemplate, getFullThemeList } from "./themes/index.js";
import { analyzeReadability, getScoreColor, getScoreLabel } from "./ai/readability.js";
import { openSearch, updateSearchIndex } from "./ai/search-ui.js";
import { initScrollSync, toggleSync, isSyncEnabled, jumpToPreview } from "./scroll-sync.js";
import { openTemplateManager } from "./template-manager/index.js";
import { renderPreview, generateHTMLPreview } from "./preview-renderer.js";
import { loadLogoPng } from "./logo.js";
import { escapeHtml } from "./utils.js";
import { toast, confirm, conflictDialog } from "./notifications/index.js";
import { generateFontFaceCSS, getFontName } from "./fonts.js";
import { initFormattingToolbar, hasTextSelection, applyLink } from "./formatting-toolbar.js";
import { initDiagramActions } from "./diagram-actions.js";
import {
  getAllDocuments,
  saveDocument,
  deleteDocument,
  setMainDocument,
  migrateFromLocalStorage,
} from "./file-explorer/storage.js";
import { resolveIncludes, resolveIncludesWithMap } from "./file-explorer/resolver.js";
import {
  initFileExplorer,
  refreshFileList,
  toggleExplorer,
  isExplorerOpen,
} from "./file-explorer/ui.js";
import { initIncludeAutocomplete } from "./file-explorer/autocomplete.js";
import { openShareDialog, isShareFragment } from "./sharing/index.js";

export const EXAMPLE_MD = `---
title: "Technical Documentation"
subtitle: "Implementation Guide"
author: "KYOTU Technology"
date: "January 2025"
---

# Introduction

This document demonstrates the capabilities of **MD2DOCX** converter built by [KYOTU Technology](https://kyotu.tech). It supports various Markdown elements and generates professional Word documents.

## Text Formatting

Text can be **bold**, *italic* or \`inline code\`. You can also combine them: ***bold and italic***. Links work too: [visit our website](https://kyotu.tech).

## Lists

### Bullet List
- First item with some details
- Second item with **bold text**
- Third item with \`code\`

### Numbered List
1. Step one - initialize the project
2. Step two - configure settings
3. Step three - deploy to production

### Task List
- [x] Project setup completed
- [x] Core features implemented
- [ ] Documentation in progress
- [ ] Final review pending

## Data Table

| Service | Status | Uptime |
|---------|--------|--------|
| **API Gateway** | Active | 99.9% |
| **Database** | Active | 99.8% |
| **CDN** | Active | 100% |

## Code Example

\`\`\`typescript
interface Document {
  title: string;
  author: string;
  content: Element[];
}

async function generateDocx(doc: Document): Promise<Blob> {
  const elements = parseMarkdown(doc.content);
  return await createDocument(doc, elements);
}
\`\`\`

## Architecture Diagram

\`\`\`mermaid
graph LR
    A[Markdown] --> B[Parser]
    B --> C{Element Type}
    C -->|Text| D[Text Renderer]
    C -->|Code| E[Syntax Highlighter]
    C -->|Diagram| F[Kroki.io]
    D --> G[DOCX Output]
    E --> G
    F --> G
\`\`\`

#### Implementation Notes

This is an H4 heading - it also appears in the table of contents with proper indentation.

---

# Summary

Document generated by **MD2DOCX** - 100% client-side processing, no server required!

Built with ❤️ by KYOTU Technology
`;

const $ = (id) => document.getElementById(id);

const markdownInput = $("markdown");
const preview = $("preview");
const status = $("status");
const statusText = $("statusText");
const metaInfo = $("metaInfo");
const metaElements = $("metaElements");
const charCount = $("charCount");
const generateBtn = $("generateBtn");
const formatDropdown = $("formatDropdown");
const fileInput = $("fileInput");
const dropzone = $("dropzone");
const loadExample = $("loadExample");
const themeSelect = $("themeSelect");
const settingsBtn = $("settingsBtn");
const settingsPanel = $("settingsPanel");
const resizer = $("resizer");
const editorPanel = $("editorPanel");
const previewPanel = $("previewPanel");
const logoInput = $("logoInput");
const logoFileName = $("logoFileName");
const resetLogo = $("resetLogo");
const readabilityBadge = $("readabilityBadge");
const readabilityPanel = $("readabilityPanel");
const readabilityMetrics = $("readabilityMetrics");
const scrollSyncToggle = $("scrollSyncToggle");
const jumpToBtn = $("jumpToBtn");
const modeContinuous = $("modeContinuous");
const modePages = $("modePages");
const manageTemplatesBtn = $("manageTemplatesBtn");
const explorerToggle = $("explorerToggle");
const currentDocName = $("currentDocName");
const shareBtn = $("shareBtn");

let customLogoDataUrl = null;
let previewMode = "continuous";
let currentDocId = null;
let allDocuments = [];

const exportOptions = {
  showTitlePage: true,
  showToc: true,
  showHeader: true,
  showFooter: true,
  customLogo: null,
};

const toggles = {
  toggleTitlePage: "showTitlePage",
  toggleToc: "showToc",
  toggleHeader: "showHeader",
  toggleFooter: "showFooter",
};

Object.keys(toggles).forEach((id) => {
  const el = $(id);
  el.addEventListener("click", () => {
    const key = toggles[id];
    exportOptions[key] = !exportOptions[key];
    el.classList.toggle("active", exportOptions[key]);
    try {
      localStorage.setItem(
        "md2docx-options",
        JSON.stringify({
          showTitlePage: exportOptions.showTitlePage,
          showToc: exportOptions.showToc,
          showHeader: exportOptions.showHeader,
          showFooter: exportOptions.showFooter,
        })
      );
    } catch {}
  });
});

try {
  const savedOptions = localStorage.getItem("md2docx-options");
  if (savedOptions) {
    const opts = JSON.parse(savedOptions);
    Object.keys(opts).forEach((key) => {
      if (key in exportOptions) {
        exportOptions[key] = opts[key];
      }
    });
    Object.keys(toggles).forEach((id) => {
      const key = toggles[id];
      $(id).classList.toggle("active", exportOptions[key]);
    });
  }
} catch {}

settingsBtn.addEventListener("click", () => {
  settingsPanel.classList.toggle("open");
  if (settingsPanel.classList.contains("open")) {
    settingsBtn.style.color = "#f97c00";
  } else {
    settingsBtn.style.color = "";
  }
});

logoInput.addEventListener("change", (e) => {
  const file = e.target.files[0];
  if (file && file.type.startsWith("image/")) {
    const reader = new FileReader();
    reader.onload = (ev) => {
      customLogoDataUrl = ev.target.result;
      exportOptions.customLogo = customLogoDataUrl;
      logoFileName.textContent = file.name.length > 15 ? file.name.slice(0, 12) + "..." : file.name;
      resetLogo.classList.remove("hidden");
    };
    reader.readAsDataURL(file);
  }
});

resetLogo.addEventListener("click", () => {
  customLogoDataUrl = null;
  exportOptions.customLogo = null;
  logoInput.value = "";
  const themeId = themeSelect.value;
  if (themeId === "kyotu") {
    logoFileName.textContent = "KYOTU (default)";
  } else if (themeId.startsWith("user-")) {
    logoFileName.textContent = "Custom template";
  } else {
    logoFileName.textContent = "None";
  }
  resetLogo.classList.add("hidden");
});

themeSelect.addEventListener("change", () => {
  updatePreview();
  if (!customLogoDataUrl) {
    const themeId = themeSelect.value;
    if (themeId === "kyotu") {
      logoFileName.textContent = "KYOTU (default)";
    } else if (themeId.startsWith("user-")) {
      logoFileName.textContent = "Custom template";
    } else {
      logoFileName.textContent = "None";
    }
  }
  try {
    localStorage.setItem("md2docx-theme", themeSelect.value);
  } catch {}
});

generateBtn.addEventListener("click", () => {
  formatDropdown.classList.toggle("hidden");
});

document.addEventListener("click", (e) => {
  if (!generateBtn.contains(e.target) && !formatDropdown.contains(e.target)) {
    formatDropdown.classList.add("hidden");
  }
});

document.querySelectorAll(".format-option").forEach((btn) => {
  btn.addEventListener("click", async () => {
    const format = btn.dataset.format;
    formatDropdown.classList.add("hidden");
    await generateDocument(format);
  });
});

let isResizing = false;
resizer.addEventListener("mousedown", () => {
  isResizing = true;
  resizer.classList.add("dragging");
  document.body.style.cursor = "col-resize";
  document.body.style.userSelect = "none";
});

document.addEventListener("mousemove", (e) => {
  if (!isResizing) return;

  const container = editorPanel.parentElement;
  const containerRect = container.getBoundingClientRect();
  const percentage = ((e.clientX - containerRect.left) / containerRect.width) * 100;
  const clampedPercentage = Math.min(Math.max(percentage, 20), 80);

  editorPanel.style.flex = `0 0 ${clampedPercentage}%`;
  previewPanel.style.flex = `0 0 ${100 - clampedPercentage - 1}%`;
});

document.addEventListener("mouseup", () => {
  if (isResizing) {
    isResizing = false;
    resizer.classList.remove("dragging");
    document.body.style.cursor = "";
    document.body.style.userSelect = "";
  }
});

async function initThemeSelect() {
  const allThemes = await getFullThemeList();

  themeSelect.innerHTML = "";

  const builtinGroup = document.createElement("optgroup");
  builtinGroup.label = "Built-in";

  const userGroup = document.createElement("optgroup");
  userGroup.label = "Your Templates";

  let hasUserTemplates = false;

  for (const theme of allThemes) {
    const option = document.createElement("option");
    option.value = theme.id;
    option.textContent = theme.name;

    if (theme.isBuiltin) {
      builtinGroup.appendChild(option);
    } else {
      userGroup.appendChild(option);
      hasUserTemplates = true;
    }
  }

  themeSelect.appendChild(builtinGroup);
  if (hasUserTemplates) {
    themeSelect.appendChild(userGroup);
  }

  try {
    const savedTheme = localStorage.getItem("md2docx-theme");
    if (savedTheme && allThemes.some((t) => t.id === savedTheme)) {
      themeSelect.value = savedTheme;
    }
  } catch {}
}

async function initDocuments() {
  await migrateFromLocalStorage();
  allDocuments = await getAllDocuments();

  if (allDocuments.length === 0) {
    await saveDocument({ name: "main.md", content: "", isMain: true });
    allDocuments = await getAllDocuments();
  }

  const mainDoc = allDocuments.find((d) => d.isMain) || allDocuments[0];
  currentDocId = mainDoc.id;
  markdownInput.value = mainDoc.content;
  updateCurrentDocLabel();
  refreshFileList(allDocuments, currentDocId);
  updatePreview();

  if (isShareFragment(window.location.hash)) {
    const { handleShareFragment } = await import("./sharing/import-handler.js");
    await handleShareFragment(window.location.hash, importSharedFiles);
  }
}

function updateCurrentDocLabel() {
  const doc = allDocuments.find((d) => d.id === currentDocId);
  if (currentDocName && doc) {
    currentDocName.textContent = doc.name;
    currentDocName.title = doc.name;
  }
}

async function switchDocument(docId) {
  if (docId === currentDocId) return;

  const currentDoc = allDocuments.find((d) => d.id === currentDocId);
  if (currentDoc) {
    currentDoc.content = markdownInput.value;
    await saveDocument(currentDoc);
  }

  const nextDoc = allDocuments.find((d) => d.id === docId);
  if (!nextDoc) return;

  currentDocId = docId;
  markdownInput.value = nextDoc.content;
  updateCurrentDocLabel();
  refreshFileList(allDocuments, currentDocId);
  updatePreview();
}

async function addDocument(name) {
  if (!name?.trim()) return;
  const trimmed = name.trim();

  if (allDocuments.some((d) => d.name === trimmed)) {
    toast.warning(`File "${trimmed}" already exists`);
    return;
  }

  const doc = await saveDocument({ name: trimmed, content: "", isMain: false });
  allDocuments = await getAllDocuments();
  refreshFileList(allDocuments, currentDocId);
  await switchDocument(doc.id);
}

async function removeDocument(docId) {
  const doc = allDocuments.find((d) => d.id === docId);
  if (!doc || doc.isMain) return;

  const ok = await confirm({
    title: "Delete file?",
    message: `Delete "${doc.name}"? This action cannot be undone.`,
    confirmText: "Delete",
    confirmStyle: "danger",
  });
  if (!ok) return;

  await deleteDocument(docId);
  allDocuments = await getAllDocuments();

  if (currentDocId === docId) {
    const mainDoc = allDocuments.find((d) => d.isMain) || allDocuments[0];
    currentDocId = mainDoc.id;
    markdownInput.value = mainDoc.content;
    updateCurrentDocLabel();
    updatePreview();
  }

  refreshFileList(allDocuments, currentDocId);
}

async function renameDocument(docId, newName) {
  const doc = allDocuments.find((d) => d.id === docId);
  if (!doc) return;

  if (allDocuments.some((d) => d.id !== docId && d.name === newName)) {
    toast.warning(`File "${newName}" already exists`);
    refreshFileList(allDocuments, currentDocId);
    return;
  }

  doc.name = newName;
  await saveDocument(doc);
  allDocuments = await getAllDocuments();
  updateCurrentDocLabel();
  refreshFileList(allDocuments, currentDocId);
}

async function changeMainDocument(docId) {
  await setMainDocument(docId);
  allDocuments = await getAllDocuments();
  refreshFileList(allDocuments, currentDocId);
  updatePreview();
}

initThemeSelect().then(() => initDocuments());

manageTemplatesBtn?.addEventListener("click", () => {
  openTemplateManager((selectedId) => {
    if (selectedId) {
      themeSelect.value = selectedId;
      updatePreview();
    }
  });
});

const emptyStateHTML = `
<div class="text-center py-12">
  <div class="w-16 h-16 mx-auto mb-4 rounded-full bg-gradient-to-br from-kyotu-orange-light/20 to-kyotu-orange/20 flex items-center justify-center">
    <svg class="w-8 h-8 text-kyotu-orange" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
    </svg>
  </div>
  <p class="text-gray-400">Document preview will appear here</p>
  <p class="text-gray-300 text-sm mt-1">Start typing or load an example</p>
</div>
`;

function showStatus(text) {
  status.classList.remove("hidden");
  statusText.textContent = text;
}

function hideStatus() {
  status.classList.add("hidden");
}

function updateReadabilityUI(analysis) {
  if (!analysis || analysis.wordCount < 10) {
    readabilityBadge.style.display = "none";
    readabilityPanel.classList.remove("open");
    return;
  }

  const color = getScoreColor(analysis.score);
  const label = getScoreLabel(analysis.score);
  readabilityBadge.style.display = "";
  readabilityBadge.style.background = color + "20";
  readabilityBadge.style.color = color;
  readabilityBadge.textContent = `${analysis.score}/100`;
  readabilityBadge.title = `Quality: ${label}`;

  const issues = [];
  if (analysis.headingIssues.length > 0) {
    issues.push(
      ...analysis.headingIssues.map(
        (h) =>
          `<span class="text-red-500 cursor-pointer" data-line="${h.line}">Heading skip: ${h.got} after ${h.expected} "${escapeHtml(h.content)}"</span>`
      )
    );
  }
  if (analysis.passiveVoice.percent > 15) {
    issues.push(
      `<span class="text-yellow-600">High passive voice: ${analysis.passiveVoice.percent}%</span>`
    );
  }
  if (analysis.avgSentenceLength > 25) {
    issues.push(
      `<span class="text-yellow-600">Long sentences: avg ${analysis.avgSentenceLength} words</span>`
    );
  }

  readabilityMetrics.innerHTML = `
    <div class="grid grid-cols-2 sm:grid-cols-3 gap-3 text-xs">
      <div class="metric-row flex-col items-start gap-0.5">
        <span class="metric-label">Flesch-Kincaid Grade</span>
        <span class="metric-value">${analysis.fleschKincaid.grade}</span>
      </div>
      <div class="metric-row flex-col items-start gap-0.5">
        <span class="metric-label">Readability Score</span>
        <span class="metric-value">${analysis.fleschKincaid.score}</span>
      </div>
      <div class="metric-row flex-col items-start gap-0.5">
        <span class="metric-label">Avg Sentence Length</span>
        <span class="metric-value">${analysis.avgSentenceLength} words</span>
      </div>
      <div class="metric-row flex-col items-start gap-0.5">
        <span class="metric-label">Passive Voice</span>
        <span class="metric-value">${analysis.passiveVoice.percent}%</span>
      </div>
      <div class="metric-row flex-col items-start gap-0.5">
        <span class="metric-label">Vocabulary Richness</span>
        <span class="metric-value">${analysis.vocabulary.richness}</span>
      </div>
      <div class="metric-row flex-col items-start gap-0.5">
        <span class="metric-label">Words / Sentences</span>
        <span class="metric-value">${analysis.wordCount} / ${analysis.sentenceCount}</span>
      </div>
    </div>
    ${
      analysis.sectionBalance.sections.length > 1
        ? `<div class="mt-2 text-xs">
        <span class="metric-label">Section Balance:</span>
        <div class="flex gap-1 mt-1 items-end h-8">
          ${analysis.sectionBalance.sections
            .map((s) => {
              const maxWords = Math.max(...analysis.sectionBalance.sections.map((x) => x.words));
              const h = maxWords > 0 ? Math.max(4, (s.words / maxWords) * 32) : 4;
              return `<div title="${escapeHtml(s.heading)}: ${s.words} words" class="bg-kyotu-orange/60 rounded-t" style="width:${100 / analysis.sectionBalance.sections.length}%;height:${h}px"></div>`;
            })
            .join("")}
        </div>
      </div>`
        : ""
    }
    ${
      issues.length > 0
        ? `<div class="mt-2 space-y-1 text-xs">${issues.map((i) => `<div>${i}</div>`).join("")}</div>`
        : ""
    }
  `;
}

async function updatePreview() {
  const md = markdownInput.value;
  charCount.textContent = `${md.length} chars`;

  const currentDoc = allDocuments.find((d) => d.id === currentDocId);
  if (currentDoc) {
    currentDoc.content = md;
    saveDocument(currentDoc).catch(() => toast.error("Failed to save document"));
  }

  if (!md.trim()) {
    preview.innerHTML = emptyStateHTML;
    preview.classList.remove("page-mode");
    metaInfo.classList.add("hidden");
    readabilityBadge.style.display = "none";
    readabilityPanel.classList.remove("open");
    return;
  }

  let previewMd = md;
  let includeLineMap = null;
  if (currentDoc?.isMain && allDocuments.length > 1) {
    const docsMap = new Map(allDocuments.map((d) => [d.name, d.content]));
    const result = resolveIncludesWithMap(md, docsMap);
    previewMd = result.resolved;
    includeLineMap = result.lineMap;
  }

  const { metadata, body } = parseMarkdown(previewMd);
  const elements = parseBodyToElements(body);

  if (includeLineMap) {
    const metadataLineCount = previewMd.split("\n").length - body.split("\n").length;
    for (const el of elements) {
      if (el.line !== undefined) {
        const resolvedLine = el.line + metadataLineCount;
        el.line = includeLineMap[resolvedLine] ?? el.line;
      }
    }
  }
  const themeId = themeSelect.value;
  const theme = await getThemeOrTemplate(themeId);

  let logoDataUrl = null;
  if (theme.titlePage?.showLogo) {
    logoDataUrl = customLogoDataUrl || theme.logo?.dataUrl || (await loadLogoPng(1, null));
  }

  if (previewMode === "pages") {
    const previewOptions = { logoDataUrl, pagedMode: true };
    await updatePreviewPaged(elements, metadata, theme, previewOptions);
  } else {
    const previewOptions = { logoDataUrl, interactive: true };
    preview.classList.remove("page-mode");
    await renderPreview(preview, elements, metadata, theme, previewOptions);
  }

  metaElements.textContent = elements.length;
  metaInfo.classList.remove("hidden");

  const analysis = analyzeReadability(elements);
  updateReadabilityUI(analysis);

  updateSearchIndex(elements);
}

async function updatePreviewPaged(elements, metadata, theme, options = {}) {
  preview.classList.add("page-mode");

  const htmlContent = generateHTMLPreview(elements, metadata, theme, options);

  const escapedTitle = metadata.title
    ? metadata.title.replace(/\\/g, "\\\\").replace(/"/g, '\\"')
    : "";

  const f = theme.fonts;
  const s = theme.sizes;
  const sp = theme.spacing;
  const c = theme.colors;

  const hpToPx = (hp) => (hp / 2) * (16 / 12);
  const twipsToPx = (tw) => tw / 20;

  const fontBaseUrl = window.location.origin + window.location.pathname.replace(/\/[^/]*$/, "");
  const fontFaceCSS = generateFontFaceCSS(fontBaseUrl);

  const headingFont = getFontName(f.heading);
  const bodyFont = getFontName(f.body);
  const monoFont = getFontName(f.mono);

  const pageStyles = `
    @page {
      size: A4;
      margin: 25mm 20mm 25mm 20mm;
      @top-center {
        content: "${escapedTitle}";
        font-family: "${bodyFont}", sans-serif;
        font-size: 10pt;
        color: #6b7280;
      }
      @bottom-center {
        content: counter(page);
        font-family: "${bodyFont}", sans-serif;
        font-size: 10pt;
        color: #6b7280;
      }
    }
    @page :first {
      @top-center { content: none; }
      @bottom-center { content: none; }
    }
    html, body {
      margin: 0;
      padding: 0;
      background: #e5e7eb;
    }
    body {
      font-family: "${headingFont}", serif;
      color: #${c.text};
    }
    .pagedjs_pages {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      gap: 20px;
    }
    .pagedjs_page {
      background: white;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    }
    h1, h2, h3, h4 { font-family: "${headingFont}", serif; color: #${c.primary}; break-after: avoid; }
    h1 { font-size: ${hpToPx(s.h1)}px; font-weight: 700; margin: ${twipsToPx(sp.h1Before)}px 0 ${twipsToPx(sp.h1After)}px; }
    h2 { font-size: ${hpToPx(s.h2)}px; font-weight: 600; margin: ${twipsToPx(sp.h2Before)}px 0 ${twipsToPx(sp.h2After)}px; }
    h3 { font-size: ${hpToPx(s.h3)}px; font-weight: 600; margin: ${twipsToPx(sp.h3Before)}px 0 ${twipsToPx(sp.h3After)}px; }
    h4 { font-size: ${hpToPx(s.h4)}px; font-weight: 600; margin: ${twipsToPx(sp.h4Before)}px 0 ${twipsToPx(sp.h4After)}px; }
    p { margin: 0 0 ${twipsToPx(sp.paraAfter)}px; line-height: 1.7; font-family: "${bodyFont}", sans-serif; font-size: ${hpToPx(s.body)}px; }
    ul, ol { margin: 0 0 ${twipsToPx(sp.paraAfter)}px 1.5rem; font-family: "${bodyFont}", sans-serif; font-size: ${hpToPx(s.body)}px; }
    li { margin: 0.25rem 0; }
    pre { break-inside: avoid; padding: 1rem; border-radius: 0.5rem; margin: 0.75rem 0; background: #${c.codeBg}; border: 1px solid #${c.codeBorder}; overflow-x: auto; }
    pre code { background: transparent !important; padding: 0; }
    code { font-family: "${monoFont}", monospace; font-size: ${hpToPx(s.mono)}px; }
    p code { background: #${c.codeBg}; padding: 0.125rem 0.375rem; border-radius: 0.25rem; border: 1px solid #${c.codeBorder}; }
    table { break-inside: avoid; border-collapse: collapse; width: 100%; margin: 0.75rem 0; font-family: "${bodyFont}", sans-serif; font-size: ${hpToPx(s.table)}px; }
    th, td { padding: 0.625rem 0.75rem; text-align: left; border: 1px solid #${c.tableBorder}; }
    th { background: #${c.tableHeader}; }
    hr { margin: 1.5rem 0; border: none; height: 2px; background: #${c.muted}; }
    img.mermaid-diagram { max-width: 100%; height: auto; display: block; margin: 1rem auto; }
    a { color: #${c.accent}; text-decoration: none; }
    .title-page { display: block; margin-bottom: 1rem; }
    .title-page-logo { margin-bottom: 2rem; }
    .title-page-title { margin: 0 0 0.5rem; }
    .title-page-line { margin: 0.75rem 0; letter-spacing: 0; }
    .title-page-break { break-before: page; height: 0; }
  `;

  const iframeHtml = `<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <style>${fontFaceCSS}</style>
  <script src="https://unpkg.com/pagedjs/dist/paged.polyfill.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/github.min.css">
  <style>${pageStyles}</style>
</head>
<body>
  ${htmlContent}
</body>
</html>`;

  preview.innerHTML = "";
  const iframe = document.createElement("iframe");
  iframe.style.cssText = "width:100%;height:100%;border:none;background:#e5e7eb;";
  iframe.srcdoc = iframeHtml;
  preview.appendChild(iframe);
}

async function generateDocument(format = "docx") {
  const mainDoc = allDocuments.find((d) => d.isMain);
  if (mainDoc && mainDoc.id === currentDocId) {
    mainDoc.content = markdownInput.value;
  }
  const mainContent = mainDoc ? mainDoc.content : markdownInput.value;

  if (!mainContent.trim()) {
    toast.warning("Main document is empty!");
    return;
  }

  generateBtn.disabled = true;
  try {
    showStatus("Parsing...");
    let exportMd = mainContent;
    if (allDocuments.length > 1) {
      const docsMap = new Map(allDocuments.map((d) => [d.name, d.content]));
      exportMd = resolveIncludes(mainContent, docsMap);
    }
    const { metadata, body } = parseMarkdown(exportMd);
    const elements = parseBodyToElements(body);
    const themeId = themeSelect.value;
    const filename = metadata.title || "document";

    if (format === "docx" || format === "all") {
      showStatus(`Generating DOCX (${elements.length} elements)...`);
      const docxBlob = await generateDocxBlob(metadata, elements, themeId, exportOptions);
      downloadBlob(docxBlob, `${filename}.docx`);
    }

    if (format === "pdf" || format === "all") {
      showStatus(`Generating PDF (${elements.length} elements)...`);
      const pdfBlob = await generatePdfBlob(metadata, elements, themeId, exportOptions);
      downloadBlob(pdfBlob, `${filename}.pdf`);
    }

    if (format === "html" || format === "all") {
      showStatus(`Generating HTML (${elements.length} elements)...`);
      const htmlBlob = await generateHtmlBlob(elements, metadata, themeId);
      downloadBlob(htmlBlob, `${filename}.html`);
    }

    hideStatus();
  } catch (err) {
    console.error(err);
    hideStatus();
    toast.error(`Error: ${err.message}`);
  } finally {
    generateBtn.disabled = false;
  }
}

function downloadBlob(blob, filename) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}

function readFileAsText(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (e) => resolve(e.target.result);
    reader.onerror = () => reject(new Error(`Failed to read ${file.name}`));
    reader.readAsText(file);
  });
}

function generateUniqueName(name, documents) {
  const dotIdx = name.lastIndexOf(".");
  const baseName = dotIdx > 0 ? name.slice(0, dotIdx) : name;
  const ext = dotIdx > 0 ? name.slice(dotIdx) : ".md";
  const existingNames = new Set(documents.map((d) => d.name));
  let counter = 2;
  let candidate = `${baseName} (${counter})${ext}`;
  while (existingNames.has(candidate)) {
    counter++;
    candidate = `${baseName} (${counter})${ext}`;
  }
  return candidate;
}

async function importSharedFiles(files, mode) {
  if (mode === "replace") {
    const mainDoc = allDocuments.find((d) => d.isMain);
    if (mainDoc) {
      mainDoc.isMain = false;
      await saveDocument(mainDoc);
    }
    for (const doc of allDocuments) {
      await deleteDocument(doc.id);
    }
    for (const file of files) {
      await saveDocument({
        name: file.name,
        content: file.content,
        isMain: !!file.isMain,
      });
    }
    allDocuments = await getAllDocuments();
    if (allDocuments.length && !allDocuments.some((d) => d.isMain)) {
      await setMainDocument(allDocuments[0].id);
      allDocuments = await getAllDocuments();
    }
    const newMain = allDocuments.find((d) => d.isMain) || allDocuments[0];
    if (newMain) {
      currentDocId = newMain.id;
      markdownInput.value = newMain.content;
    }
    updateCurrentDocLabel();
    refreshFileList(allDocuments, currentDocId);
    updatePreview();
    toast.success(`Imported ${files.length} file${files.length > 1 ? "s" : ""}`);
  } else if (mode === "merge") {
    let added = 0;
    let replaced = 0;
    let skipped = 0;

    for (const file of files) {
      const existing = allDocuments.find((d) => d.name === file.name);
      if (existing) {
        const action = await conflictDialog({
          title: "File already exists",
          message: `A file named "${file.name}" already exists. What would you like to do?`,
        });
        if (action === "replace") {
          existing.content = file.content;
          await saveDocument(existing);
          allDocuments = await getAllDocuments();
          replaced++;
        } else if (action === "keep-both") {
          const newName = generateUniqueName(file.name, allDocuments);
          await saveDocument({ name: newName, content: file.content, isMain: false });
          allDocuments = await getAllDocuments();
          added++;
        } else {
          skipped++;
        }
      } else {
        await saveDocument({ name: file.name, content: file.content, isMain: false });
        allDocuments = await getAllDocuments();
        added++;
      }
    }

    refreshFileList(allDocuments, currentDocId);
    updatePreview();

    const parts = [];
    if (added > 0) parts.push(`${added} added`);
    if (replaced > 0) parts.push(`${replaced} replaced`);
    if (skipped > 0) parts.push(`${skipped} skipped`);
    if (parts.length > 0) toast.success(`Files: ${parts.join(", ")}`);
  }
}

function isValidTextFile(file) {
  return file.name.endsWith(".md") || file.name.endsWith(".txt") || file.type === "text/plain";
}

async function handleExplorerDrop(files) {
  const validFiles = Array.from(files).filter(isValidTextFile);

  if (validFiles.length === 0) {
    toast.warning("No Markdown or text files found");
    return;
  }

  const currentDoc = allDocuments.find((d) => d.id === currentDocId);
  if (currentDoc) {
    currentDoc.content = markdownInput.value;
    await saveDocument(currentDoc);
  }

  let added = 0;
  let replaced = 0;
  let skipped = 0;
  let lastDocId = null;

  for (const file of validFiles) {
    const content = await readFileAsText(file);
    const existingDoc = allDocuments.find((d) => d.name === file.name);

    if (existingDoc) {
      const action = await conflictDialog({
        title: "File already exists",
        message: `A file named "${file.name}" already exists. What would you like to do?`,
      });

      if (action === "replace") {
        existingDoc.content = content;
        await saveDocument(existingDoc);
        allDocuments = await getAllDocuments();
        lastDocId = existingDoc.id;
        replaced++;
      } else if (action === "keep-both") {
        const newName = generateUniqueName(file.name, allDocuments);
        const doc = await saveDocument({ name: newName, content, isMain: false });
        allDocuments = await getAllDocuments();
        lastDocId = doc.id;
        added++;
      } else {
        skipped++;
      }
    } else {
      const doc = await saveDocument({ name: file.name, content, isMain: false });
      allDocuments = await getAllDocuments();
      lastDocId = doc.id;
      added++;
    }
  }

  if (lastDocId) {
    refreshFileList(allDocuments, currentDocId);
    await switchDocument(lastDocId);
  }

  const parts = [];
  if (added > 0) parts.push(`${added} added`);
  if (replaced > 0) parts.push(`${replaced} replaced`);
  if (skipped > 0) parts.push(`${skipped} skipped`);
  if (parts.length > 0) toast.success(`Files: ${parts.join(", ")}`);
}

function loadFile(file) {
  if (
    file &&
    (file.name.endsWith(".md") || file.name.endsWith(".txt") || file.type === "text/plain")
  ) {
    const reader = new FileReader();
    reader.onload = async (e) => {
      const content = e.target.result;
      markdownInput.value = content;

      if (isExplorerOpen()) {
        const currentDoc = allDocuments.find((d) => d.id === currentDocId);
        if (currentDoc) {
          currentDoc.content = content;
          await saveDocument(currentDoc);
        }
        toast.success(`Content of "${currentDoc?.name || "document"}" updated`);
      }

      updatePreview();
    };
    reader.readAsText(file);
  }
}

loadExample.addEventListener("click", () => {
  markdownInput.value = EXAMPLE_MD;
  const currentDoc = allDocuments.find((d) => d.id === currentDocId);
  if (currentDoc) currentDoc.content = EXAMPLE_MD;
  updatePreview();
});
fileInput.addEventListener("change", (e) => loadFile(e.target.files[0]));

function syncCurrentDocContent() {
  const currentDoc = allDocuments.find((d) => d.id === currentDocId);
  if (currentDoc) currentDoc.content = markdownInput.value;
}

shareBtn?.addEventListener("click", () => {
  syncCurrentDocContent();
  openShareDialog(allDocuments, currentDocId);
});

dropzone.addEventListener("dragover", (e) => {
  e.preventDefault();
  dropzone.classList.add("dragover");
});
dropzone.addEventListener("dragleave", () => dropzone.classList.remove("dragover"));
dropzone.addEventListener("drop", (e) => {
  e.preventDefault();
  dropzone.classList.remove("dragover");
  loadFile(e.dataTransfer.files[0]);
});

let previewTimeout;
markdownInput.addEventListener("input", () => {
  clearTimeout(previewTimeout);
  previewTimeout = setTimeout(updatePreview, 300);
});

markdownInput.addEventListener("keydown", (e) => {
  if (e.ctrlKey && e.key === "Enter") {
    e.preventDefault();
    generateDocument("docx");
  }
});

document.addEventListener("keydown", (e) => {
  if ((e.ctrlKey || e.metaKey) && e.key === "k") {
    e.preventDefault();
    if (document.activeElement === markdownInput && hasTextSelection(markdownInput)) {
      applyLink(markdownInput);
    } else {
      openSearch();
    }
  }
  if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase() === "l") {
    e.preventDefault();
    syncCurrentDocContent();
    openShareDialog(allDocuments, currentDocId);
  }
});

readabilityBadge.addEventListener("click", () => {
  readabilityPanel.classList.toggle("open");
});

readabilityMetrics.addEventListener("click", (e) => {
  const lineEl = e.target.closest("[data-line]");
  if (!lineEl) return;
  const line = parseInt(lineEl.dataset.line);
  const lines = markdownInput.value.split("\n");
  let charPos = 0;
  for (let i = 0; i < line && i < lines.length; i++) {
    charPos += lines[i].length + 1;
  }
  markdownInput.focus();
  markdownInput.setSelectionRange(charPos, charPos);
  markdownInput.scrollTop =
    (line / lines.length) * markdownInput.scrollHeight - markdownInput.clientHeight / 3;
});

initScrollSync(markdownInput, preview);
initFormattingToolbar(markdownInput);
initIncludeAutocomplete(markdownInput, () => allDocuments);
initDiagramActions(preview);
updateSyncToggleUI();

function updateSyncToggleUI() {
  const enabled = isSyncEnabled();
  const icon = scrollSyncToggle.querySelector("svg");
  const text = scrollSyncToggle.querySelector("span");

  if (enabled) {
    scrollSyncToggle.classList.add("text-kyotu-orange");
    scrollSyncToggle.classList.remove("text-gray-400");
    if (icon) {
      icon.innerHTML = `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"/>`;
    }
    if (text) text.textContent = "Sync";
  } else {
    scrollSyncToggle.classList.remove("text-kyotu-orange");
    scrollSyncToggle.classList.add("text-gray-400");
    if (icon) {
      icon.innerHTML = `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"/><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6"/>`;
    }
    if (text) text.textContent = "Sync";
  }
}

scrollSyncToggle.addEventListener("click", () => {
  toggleSync();
  updateSyncToggleUI();
});

jumpToBtn.addEventListener("click", jumpToPreview);

document.addEventListener("keydown", (e) => {
  if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === "S") {
    e.preventDefault();
    toggleSync();
    updateSyncToggleUI();
  }
});

function updatePreviewModeUI() {
  modeContinuous.classList.toggle("active", previewMode === "continuous");
  modePages.classList.toggle("active", previewMode === "pages");
}

function setPreviewMode(mode) {
  previewMode = mode;
  updatePreviewModeUI();
  updatePreview();
}

modeContinuous.addEventListener("click", () => setPreviewMode("continuous"));
modePages.addEventListener("click", () => setPreviewMode("pages"));

updatePreviewModeUI();

initFileExplorer($("explorerPanel"), {
  onSelect: (id) => switchDocument(id),
  onAdd: (name) => addDocument(name),
  onDelete: (id) => removeDocument(id),
  onRename: (id, name) => renameDocument(id, name),
  onSetMain: (id) => changeMainDocument(id),
  onDrop: (files) => handleExplorerDrop(files),
});

explorerToggle?.addEventListener("click", () => toggleExplorer());

document.addEventListener("keydown", (e) => {
  if ((e.ctrlKey || e.metaKey) && e.key === "b" && document.activeElement !== markdownInput) {
    e.preventDefault();
    toggleExplorer();
  }
});
